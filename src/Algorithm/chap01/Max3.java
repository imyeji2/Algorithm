package Algorithm.chap01;

import java.util.Scanner;

public class Max3 {
	public static void main(String[]args) {
		//변수 a,b,c에 값을 입력받아 세 값의 최대값 구하기 p.13
		Scanner stdIn = new Scanner(System.in);//키보드 입력을 위한 scanner
		
		System.out.println("세 정수의 최대값을 구합니다.");
		System.out.print("a의 값 : "); int a = stdIn.nextInt(); //정수 a값 입력
		System.out.print("b의 값 : "); int b = stdIn.nextInt(); //정수 b값 입력
		System.out.print("c의 값 : "); int c = stdIn.nextInt(); //정수 c값 입력
	
		//a,b,c의 최대값을 구하여 max에 대입
		int max=a; //max 초기값 세팅
		if(b>max) max=b;//b가 max보다 크면 최대값은 b
		if(c>max) max=c;//c가 max보다 크면 최대값은 c 

		System.out.println("최대값은 " + max +"입니다.");		
		
		/*변수
		 * 
		 * 1. 변수란?
		 * - 프로그램 실행에 필요한 데이터를 저장하기 위해 메모리에 공간을 만들어 할당하고 이름을 부여한 것
		 * - 데이터를 담아 놓는 메모리 공간
		 * - 데이터의 저장과 참조를 위해 할당된 메모리 공간
		 * 
		 * 2. 변수의 종류
		 * 2-1 멤버 변수(instance변수)
		 * 2-2 클래스 변수(static변수)
		 * 2-3 지역 변수(local 변수)
		 * - 메서드나 {} 블럭 안에서 선언된 변수
		 * - 지역 변수는 반드시 초기화, 초기화하지 않으면 Error남
		 * 
		 * 
		 * 
		 * */
		
		/*자바의 자료형
		 * 
		 * [1] 기본 자료형
		 * - 변수의 실제 값을 가지고 있는 것
		 * - 메모리 스택에 저장, 변수 선언과 동시에 메모리 생성
		 * - 변수 타입에 따라 메모리 크기도 달라짐
		 * - 변수 선언 시 new연산자 이용하지 않아도 자동으로 new 연산자가 호출되어 메모리가 생성되는 특징
		 * 
		 * 1.숫자
		 * 1-1 정수
		 * byte      1바이트 -128 ~ 127
		 * short     2바이트 -32,768 ~ 32.767 (대략 32000)
		 * int(기본형) 4바이트 -2,147,483,648 ~ 2,147,483,647 (대략 21억)
		 * long      8바이트 -9223372036854775808 ~ -9223372036854775807(대략 922경)
		 * 
		 * 1-2 실수(부동 소수점수)
		 * float        4바이트 소수이하 7자리
		 * double(기본형) 8바이트, 소수이하 15자리, float 보다 2배 정밀한 실수 표현
		 * ->실수는 근사치를 표현함으로 오차는 존재함, 값의 표현보다 정밀도를 우선시 해야함
		 * 
		 * -long과 float는 리터럴 뒤에 L과 F로 식별자를 반드시 적어야 한다.(습관화)
		 *  그 이유는 정수형의 경우 연산시 사용하는 기본 자료형이 int, 실수형의 경우 double이기 때문에
		 * 	int에 long을 다 담을 수 없고, float에 double을 다 담을 수 없기 때문에 오류가 발생하기 때문이다.
		 * 
		 * 2.문자(유니코드)
		 * char 2바이트 -> 문자 하나를 저장, ''로 묶어서 저장
		 * - 문자 하나를 변수에 저장하면 실제로는 해당 문자의 유니코드 값이 저장됨(연산도 가능)
		 * - 유니코드 -> 문자 하나를 2바이트로 표현하는 문자 체계, 세계 모든 언어 표현 가능
		 * - A-> 65, a-> 97, 0(숫자)->48 
		 * 
		 * 3.논리형
		 * boolean 1바이트, true/false
		 * 
		 * [2] 참조형
		 * - 값은 다른 곳에 있고 값이 있는 주소를 참조
		 * - 메모리의 힙에 실제 값을 저장하고 그 참조값을 갖는 변수는 스택에 저장
		 * - 변수의 선언과 메모리 생성 분리
		 * - class 계열들은 모두 new 연산자를 이용하여 사용자가 직접 메모리를 생성해 주어야 함
		 * - 클래스형, 인터페이스형, 배열 
		 * - String, 연속된 문자열 저장, "" 로 묶어서 저장
		 * -> String은 클래스형 중에서 기본 내장형이라 new연산자 사용 안함
		 * 
		 */
		
		/*
		 * 메모리(가상메모리)
		 * 
		 * 1 메서드 영역(메소드의 바이트 코드, static변수)
		 *  1-1. 코드 영역 : 실행할 프로그램의 코드를 올려 놓을 공간
		 *  1-2. 데이터영역 (static영역) : 프로그램이 종료될 때까지 유지해야 할 데이터를 저장할 공간
		 * 
		 * 2.힙 영역(인스턴스)
		 *  - 프로그래머가 원하는 방식으로 쓸 수 있는 공간
		 * 
		 * 3. 스택영역(지역변수, 매개변수)
		 * - 아주 잠깐 사용하고 삭제할 데이터의 저장 공간
		 * - 스택은 데이터가 아래서부터 쌓였다가 맨 위의 데이터부터 차례로 제거(LILO)
		 * 
		 * 
		 * int a;
		 * a=5;
		 * String s;
		 * s= new String("hello!");
		 * 
		 * 전체 코드는 메서드영역의 코드 영역에 로드
		 * 변수 a는 지역변수로 선언과 동시에 스택 영역에 저장
		 * 변수 s는 참조 타입으로 실제 값은 힙 영역에 저장되고
		 * 실제 값이 저장된 힙 영역의 참조값을 가진 변수s는 스택영역에 저장
		 * 
		 */
		
		
		/* 자료형 형변환
		 * - 원래의 자료형이 아닌 다른 자료형으로 변환, 연산 및 대입에서 발생함
		 * 
		 * 1. 자동 형변환(암시적 변환)
		 * - 작은 범위의 데이터를 큰 범위에 할당하는 경우
		 * - 값의 손실이 발생하지 않는 변환
		 * - 자동 형변환 규칙
		 *   byte->short->int->long->float->double
		 *       ->char
		 * 
		 * 2. 명시적 형변환
		 * - 큰 범위의 데이터를 작은 범위에 할당하는 경우 변환하고자 하는 자료형을 지정
		 * - 값의 중요한 숫자가 손실되지 않을 때만 수행해야 함
		 * 
		 * 3. 문자열 -> 숫자 형변환 
		 * - Integer.parseInt("123");
		 * - Float.parseFloat();
		 * - Double.parseDouble();
		 * - Byte.parseByte();
		 * 
		 * 4. 숫자형 -> 문자열 형변환
		 * - Integer.toString(25);
		 * - Double.toString();
		 * - Long.toString();
		 * - Float.toString();
		 * 
		 * - Boolean/Character/Byte/Short/Integer/Long/Float/Double 와 같은 걸 Wrapper 클래스라 하는데
		 * Wrapper 클래스란 자료형을 효율적으로 관리함과 동시에 완벽한 은닉화를 추구하기 위해 만들어진 자료형 대체 클래스이다.
		 */
	}	
}
